package pathFinding;

import java.awt.Point;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class PathFinding {

	WarehouseMap warehouseMap;
	
	public PathFinding(WarehouseMap warehouseMap) {
		this.warehouseMap = warehouseMap;
	}
	
	public List<Point> findPath(Point startPos, Point targetPos) {
		warehouseMap.resetNodes();
		
		Node startNode = warehouseMap.getWarehouseObject(startPos);
		Node targetNode = warehouseMap.getWarehouseObject(targetPos);
		
		List<Node> openSet = new ArrayList<>();
		Set<Node> closedSet = new HashSet<Node>();
		openSet.add(startNode);
		
		// Keep looping while open set > 0
		while(openSet.size() > 0) {
			Node currentNode = openSet.get(0);
			
			for (int i = 1; i < openSet.size(); i++) {
				if (   (openSet.get(i).fCost() < currentNode.fCost())
			        || (   (openSet.get(i).fCost() == currentNode.fCost()) 
			        	&& (openSet.get(i).hCost < currentNode.hCost))) {
					currentNode = openSet.get(i);
				}
			}
			openSet.remove(currentNode);
			closedSet.add(currentNode);
			
			if (currentNode == targetNode) {
				// Target found
				return retracePath(startNode, targetNode);
			}
				
			for (Node neighbor : warehouseMap.getNeighbors(currentNode)) {
				if (neighbor == null || closedSet.contains(neighbor)) continue;
			
				if (!neighbor.walkable && neighbor != targetNode) continue;
				
				int newMovementCostToNeighbor = currentNode.gCost + getDistance(currentNode, neighbor);
				
				if (   (newMovementCostToNeighbor < neighbor.gCost)
					|| (!openSet.contains(neighbor))){
					neighbor.gCost = newMovementCostToNeighbor;
					neighbor.hCost = getDistance(neighbor, targetNode);
					neighbor.parent = currentNode;
					
					if (!openSet.contains(neighbor)) {
						openSet.add(neighbor);
					}
				}
			}
		}
		
		// Can not find path
	    System.out.println("Can not find path");
		return new ArrayList<>(); // return null
	}
	
	public List<Point> retracePath(Node startNode, Node targetNode) {
	    List<Point> path =  new ArrayList<>();
	    
	    Node currentNode = targetNode;
	    
	    while (currentNode != startNode) {
	    	path.add(currentNode.position);
	    	currentNode = currentNode.parent;
	    }
	    
	    if (currentNode == startNode) {
	    	path.add(startNode.position);
	    	Collections.reverse(path);
	    	
	    	if (!path.isEmpty()) {
	    		path.remove(0);
	    	}
	    	
		    System.out.println("Found path from " + startNode.position + "(return " + path.size() + " steps):");
		    for (Point pos : path) {
		        System.out.printf("(%d,%d) -> ", pos.x, pos.y);
		    }
		    System.out.println("END");
		    
	    	return path;
	    	
	    } else {
	    	// parent error
	    	System.out.println("Error when finding path");
	    	return new ArrayList<>();
	    }
	}
	
	int getDistance(Node nodeA, Node nodeB) {
		int dstX = Math.absExact((int) nodeA.position.getX() - (int)nodeB.position.getX());
		int dstY = Math.absExact((int) nodeA.position.getY() - (int)nodeB.position.getY());
		
		if (dstX > dstY) {
			return 14 * dstY + 10 * (dstX - dstY);
		} else {
			return 14 * dstX + 10 * (dstY - dstX);
		}
	}
}
